1. Introduction to Databases & MySQL

Database ‚Üí An organized collection of data that can be easily accessed, managed, and updated.

Types of Databases:

Relational Database (RDBMS) ‚Äì Data is stored in tables (rows & columns) with relationships (e.g., MySQL, PostgreSQL, Oracle).

NoSQL Database ‚Äì Flexible schema, stores data in documents, key-value pairs, graphs, or wide columns (e.g., MongoDB, Cassandra).

MySQL ‚Üí An open-source relational database management system (RDBMS).

Uses SQL (Structured Query Language) to interact with the data.

Known for speed, reliability, and simplicity.

Used in web applications (WordPress, Facebook early days, e-commerce apps, etc.).

2. Relational Database Concepts

Table ‚Äì Stores data in rows (records) and columns (fields).

Primary Key ‚Äì Unique identifier for each row (e.g., user_id).

Foreign Key ‚Äì Links one table to another (enforces relationships).

Normalization ‚Äì Process of organizing data to reduce redundancy and improve consistency (1NF, 2NF, 3NF).

Joins ‚Äì Combining rows from multiple tables:

INNER JOIN ‚Äì only matching records.

LEFT JOIN ‚Äì all from left + matched from right.

RIGHT JOIN ‚Äì all from right + matched from left.

FULL JOIN ‚Äì all records from both (not directly supported in MySQL, but can be simulated).

üëâ Example:
users and orders tables ‚Üí A foreign key in orders links to a primary key in users.

3. MySQL Architecture & Storage Engines
MySQL Architecture

Client Layer ‚Äì Applications, command-line client, MySQL Workbench.

Connection Layer ‚Äì Authentication, security, thread handling.

SQL Layer ‚Äì Parsing SQL, query optimization, execution plan.

Storage Engine Layer ‚Äì Actual data storage and retrieval (pluggable engines like InnoDB, MyISAM).

Storage Engines

MySQL allows you to choose a storage engine for each table.

InnoDB (default)
‚úÖ Supports ACID transactions.
‚úÖ Row-level locking ‚Üí better for high concurrency.
‚úÖ Supports foreign keys (referential integrity).
‚úÖ Crash recovery with redo/undo logs.
‚ö° Best for OLTP (Online Transaction Processing) apps (banking, e-commerce).

MyISAM (older engine)
‚ùå No transaction support.
‚ùå No foreign keys.
‚ùå Table-level locking ‚Üí not good for concurrent writes.
‚úÖ Faster for read-heavy applications (analytics, reporting).

üëâ Rule of Thumb: Use InnoDB unless you have a special read-heavy case.

4. Data Types in MySQL

MySQL provides different categories of data types:

Numeric Types

INT / BIGINT ‚Üí Whole numbers.

DECIMAL(p,s) ‚Üí Fixed precision (money, financial).

FLOAT / DOUBLE ‚Üí Approximate floating-point numbers (scientific data).

String Types

CHAR(n) ‚Üí Fixed-length (faster but wastes space).

VARCHAR(n) ‚Üí Variable-length (saves space, most common).

TEXT ‚Üí Long text (articles, comments).

BLOB ‚Üí Binary large object (images, files).

Date & Time Types

DATE ‚Üí YYYY-MM-DD

DATETIME / TIMESTAMP ‚Üí YYYY-MM-DD HH:MM:SS

TIME ‚Üí HH:MM:SS

JSON Type

Stores structured JSON data.

Can query inside JSON using JSON_EXTRACT().

Useful for semi-structured data (logs, metadata).

Spatial Types

GEOMETRY, POINT, LINESTRING, POLYGON.

Useful in GIS (Geographic Information Systems).

5. ACID Properties & Transactions

Databases ensure reliability using ACID properties:

A ‚Üí Atomicity

A transaction is all or nothing.

Example: Money transfer ‚Üí Deduct ‚Çπ100 from Account A AND add ‚Çπ100 to Account B. If one fails, both rollback.

C ‚Üí Consistency

Database remains in a valid state before & after a transaction.

Constraints (primary key, foreign key, unique, NOT NULL) are enforced.

I ‚Üí Isolation

Multiple transactions don‚Äôt interfere.

Controlled by isolation levels:

READ UNCOMMITTED ‚Üí Dirty reads allowed (fast, unsafe).

READ COMMITTED ‚Üí No dirty reads (default in many DBs).

REPEATABLE READ ‚Üí Prevents non-repeatable reads (MySQL default).

SERIALIZABLE ‚Üí Strictest, prevents phantom reads (slowest).

D ‚Üí Durability

Once committed, data is permanently saved (even after crash).

Achieved via redo logs, write-ahead logging.



.......................
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;  -- saves permanently
-- or ROLLBACK;  -- undo if error





diagram of how MySQL works (from client request to storage engine):

+----------------------+
|   Client / Tools     |   ‚Üê (MySQL Client, Workbench, Apps, APIs)
+----------------------+
            |
            v
+----------------------+
|  Connection Layer    |   ‚Üê (Authentication, Security, Thread Management)
+----------------------+
            |
            v
+----------------------+
|      SQL Layer       |   ‚Üê (Parser, Optimizer, Query Cache, Executor)
+----------------------+
            |
            v
+----------------------+
| Storage Engine Layer |   ‚Üê (InnoDB, MyISAM, Memory, CSV, etc.)
+----------------------+
            |
            v
+----------------------+
|   Physical Storage   |   ‚Üê (Disk / SSD files, Logs, Indexes, Data Files)
+----------------------+


üîë Explanation of each layer:

Client Layer ‚Üí User or application sends SQL queries (e.g., SELECT * FROM users;).

Connection Layer ‚Üí Handles login, permissions, and manages client threads.

SQL Layer ‚Üí

Parser ‚Üí Breaks SQL into tokens (SELECT, FROM, etc.).

Optimizer ‚Üí Chooses the fastest way (indexes, join order).

Executor ‚Üí Runs the optimized query.

Storage Engine Layer ‚Üí Where data actually lives. InnoDB, MyISAM, Memory, etc.

Physical Storage ‚Üí Final layer where data is stored on disk with indexes, redo/undo logs.
